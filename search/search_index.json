{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"One-day BAM Workshop: Automatizing Data Management with PyBIS and the BAM Parser Infrastructure","text":"<p>Welcome to the one-day workshop at BAM to learn Python tools for Research Data Management (RDM) with openBIS. This page is organized in the three parts or tutorials presented during the workshop:</p> <ul> <li>Part 1 - Basic pyBIS Introduction: you will learn how to do basic calls using pyBIS and about the available Entities in an openBIS instance.</li> <li>Part 2 - Advanced pyBIS Features: you will learn to create new Entities, their parent-child relationships, and automate searches and filters using pyBIS.</li> <li>Part 3 - BAM Parsers: you will learn how to automate data ingestion by creating new entities and their parent-child relationships using the BAM Parser Infrastructure.</li> </ul> <p>In order to work throughout the tutorials, you will need to install in your laptop:</p> <ol> <li>Visual Studio Code (VSCode)</li> <li>Miniforge3 with Python3.12</li> </ol> <p>We also recommend installing a few VSCode extensions which will allow you to open and work with Python and Jupyter Notebooks:</p> <ul> <li>Python: https://marketplace.visualstudio.com/items?itemName=ms-python.python</li> <li>Jupyter: https://marketplace.visualstudio.com/items?itemName=ms-toolsai.jupyter</li> </ul>"},{"location":"#setting-up-a-working-vscode-with-python-in-windows","title":"Setting up a working VSCode with Python in Windows","text":"<p>Then, open VSCode and open a terminal. In order to run commands with Miniforge3 and Python, you need to make sure the terminal is running with <code>cmd</code>. Do:</p> <pre><code>Ctrl+Shift+P \u2192 Terminal: Select Default Profile \u2192 Command Prompt\n</code></pre> <p></p> <p>After that, run in the terminal:</p> <pre><code>C:\\Miniforge3\\Scripts\\conda.exe init cmd.exe\n</code></pre> <p>Note: the path <code>C:\\Miniforge3\\Scripts</code> might be different in your case. As of January 2026, this is the path where Miniforge3 is installed in BAM laptops.</p> <p>After running this command in the terminal, close VSCode completely, and reopen it.</p> <p>You can verify installation and the proper location of paths if when running:</p> <pre><code>conda --version\n</code></pre> <p>or</p> <pre><code>where conda\n</code></pre> <p>You get back an answer with the version or path where Miniforge3 has the <code>conda</code> installer located.</p> <p>We can close VSCode completely, again, and when launching it again and opening a new terminal, we should see <code>(base)</code> at the beginning of your path. You can verify that:</p> <pre><code>echo %CONDA_DEFAULT_ENV%\n</code></pre> <p>returns <code>base</code>.</p> <p>If everything went good, you can also launch the interactive Python terminal:</p> <pre><code>python\n</code></pre> <p>And you will get:</p> <pre><code>Python 3.12.12 | packaged by conda-forge | (main, Jan 26 2026, 23:38:32) [MSC v.1944 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\nCtrl click to launch VS Code Native REPL\n&gt;&gt;&gt;\n</code></pre>"},{"location":"#setup-the-tutorial-workspace","title":"Setup the tutorial workspace","text":"<p>Now, we can create a new folder (done with the command <code>mkdir</code>) in the directory we will be working in this tutorial. Then, we also move to it (with <code>cd</code>):</p> <pre><code>mkdir tutorials\ncd tutorials\n</code></pre> <p>In this folder, you can create a new conda environment (answer <code>y</code> during the creation of the environment) with Python 3.12:</p> <pre><code>conda create -n pybis_tuto python=3.12\n</code></pre> <p>And activate it:</p> <pre><code>conda activate pybis_tuto\n</code></pre> <p>Then, we will need to install a few packages:</p> <pre><code>pip install pybis jupyter jupyterlab\n</code></pre> <p>Note: in order to speed up the process, you can also pre-install uv in your laptop and run the command above with <code>uv</code> in front, i.e.:</p> <pre><code>uv pip install pybis jupyter jupyterlab\n</code></pre> <p>You can verify that the installation works by running the interactive Python terminal and import a specific pybis object:</p> <pre><code>python\n</code></pre> <p>And in the interactive Python terminal, import:(without the <code>&gt;&gt;&gt;</code>): <pre><code>&gt;&gt;&gt; from pybis import Openbis\n</code></pre></p> <p>If everything went good, after a few seconds, you would be able to instantiate the class <code>Openbis</code>.</p> <pre><code>&gt;&gt;&gt; from pybis import Openbis\n&gt;&gt;&gt; Openbis\n&lt;class 'pybis.pybis.Openbis'&gt;\n</code></pre>"},{"location":"part1-basic_introduction/","title":"Part 1 - Basic pyBIS introduction","text":"<p>In openBIS, there are two main modes in which data is defined by users for storage in the platform:</p> <ol> <li>Manual annotation of data via the Graphical User Interface (GUI).</li> <li>Automated data ingestion via an Application Programming Interface (API).</li> </ol> <p>In this part, you will learn the basics of the openBIS API in Python, also called pyBIS.</p> Tip <p>We recommend the reader to launch a Jupyter Notebook in a Python environment with <code>pyBIS</code> installed, and run the commands shown throughout the next sections.</p>"},{"location":"part1-basic_introduction/#initial-setup-connecting-to-openbis","title":"Initial Setup: Connecting to openBIS","text":"<p>The first step to start using pyBIS is to connect to the specific instance where we will work.</p> <p>We can define some variables:</p> <pre><code>URL = \"&lt;path-to-openbis-instance&gt;\"\nUSERNAME = \"&lt;your-bam-username&gt;\" \nPASSWORD = \"&lt;your-password&gt;\n</code></pre> <p>Warning</p> <p>Note that you must not openly distribute the URL, as well as your USERNAME and PASSWORD. In case you are working in open repositories (e.g., in GitHub), ,ake sure that, before pushing content, these are deleted or anonymized. There are other safer implementations to define such variables (e.g., secret environments) which can help you manage your username and passwords securely.</p> <p>You can log in openbis with:</p> <pre><code>from pybis import Openbis\n\no = Openbis(URL)\no.login(USERNAME, PASSWORD)\n</code></pre> <p>After a few seconds, <code>o</code> will connect with your credentials to the openBIS instance specified in <code>URL</code>.</p> <p>We can check if the session is active:</p> <pre><code>o.is_session_active()\n</code></pre> <p>Or check the openBIS version:</p> <pre><code>o.get_server_information().openbis_version\n</code></pre> <p>We can also define a personal access token (PAT):</p> <pre><code>PAT = o.get_or_create_personal_access_token(sessionName=\"My Tutorial Session\")\n</code></pre> <p>And use it for login instead of the username and password</p> <pre><code>o = Openbis(URL)\no.set_token(PAT, save_token=True)\n</code></pre>"},{"location":"part1-basic_introduction/#exploring-openbis-available-folders-and-entities","title":"Exploring openBIS Available Folders and Entities","text":"<p>In openBIS, we organize data following the structure: Space &gt; Projects &gt; Collections (optional) &gt; Objects. Spaces and Projects are folder-like structure where to store the research workflow we did. This research workflow is described by Objects and the parent-child relationships defined between them. Collections are an optional way of grouping multiple objects under the same category. </p> <p>Besides this structure, Datasets (i.e., entities containing raw data like files) can be attached to Objects (or Collections) to store the raw data out of which metadata was defined.</p> <p>In this sub-section, you will see how to use pyBIS to explore the available Spaces, Projects, (Collections,) and Objects in the openBIS instance <code>o</code>. This will help later when building the data model with Objects and their parent-child relationships (see Part 2 - Advanced pyBIS features).</p>"},{"location":"part1-basic_introduction/#spaces-and-projects","title":"Spaces and Projects","text":"<p>We can get all the available Spaces in an openBIS instance by doing:</p> <pre><code>o.get_spaces()\n</code></pre> <p>When we want to work inside a specific Space, we can use its code and create a variable as:</p> <pre><code>my_space = o.get_spaces(\"&lt;SPACE-CODE&gt;\")\n</code></pre> <p>We can then get a specific project from that space:</p> <pre><code>my_project = my_space.get_project(\"&lt;PROJECT-CODE&gt;\")\n</code></pre> <p>Similarly to Spaces, we can know the available projects defined in an instance:</p> <pre><code>o.get_projects()\n</code></pre> <p><code>my_project</code> will define the Project folder where we can store data.</p> <p>Hint</p> <p>Note that the plural (<code>get_spaces</code>, <code>get_projects</code>) is used on an <code>Openbis</code> instance to return the available folders in that instance. The singular is then used to define one single folder (space, project) of the available ones.</p>"},{"location":"part1-basic_introduction/#collections","title":"Collections","text":"<p>We can list all collections in an instance, space, or project by respectively doing:</p> <pre><code>o.get_collections()\nmy_space.get_collections()\nmy_project.get_collections()\n</code></pre> <p>We can also specify one based on the path:</p> <pre><code>my_collection = o.get_collection(\"/&lt;SPACE-CODE&gt;/&lt;PROJECT-CODE&gt;/&lt;COLLECTION-CODE&gt;\")\n</code></pre> <p>If you don't know the path, you can either find the one when calling <code>get_collections()</code> or, go to your openBIS instance and check a Collection metadata:</p> <p></p> <p>You can also use the <code>permID</code>:</p> <pre><code>my_collection = o.get_collection(permID)\n</code></pre>"},{"location":"part1-basic_introduction/#objects-and-datasets","title":"Objects and Datasets","text":"<p>Objects are also found equivalently to Collections, with the exception that Objects might also be grouped inside a Collection:</p> <pre><code>o.get_objects()\nmy_space.get_objects()\nmy_project.get_objects()\nmy_collection.get_objects()\n</code></pre> <p>Similarly, using the specific path or <code>permID</code>:</p> <pre><code>my_object = o.get_object(\"/&lt;SPACE-CODE&gt;/&lt;PROJECT-CODE&gt;/&lt;COLLECTION-CODE&gt;/&lt;OBJECT-CODE&gt;\")\n# Alternative 1 (in case the Object is directly under Project):\n# my_object = o.get_object(\"/&lt;SPACE-CODE&gt;/&lt;PROJECT-CODE&gt;/&lt;OBJECT-CODE&gt;\")\n# Alternative 2:\n# my_object = o.get_object(permID)\n</code></pre> <p>Datasets follow the same functionalities with <code>get_datasets()</code> and <code>get_dataset()</code>, and can be attached to Collections or Objects. We can also download a specific dataset (e.g., defined by a <code>permID</code>):</p> <pre><code>o.get_dataset(permID).download()\n</code></pre> <p>And even specify the path directory where to download:</p> <pre><code>o.get_dataset(permID).download(destination=\"my_downloads\", create_default_folders=False)\n</code></pre>"},{"location":"part2-advanced_features/","title":"Part 2 - Advanced pyBIS features","text":"<p>In this part, you will learn the how to use pyBIS to create new Projects and Entities (Collections, Objects, Datasets), the parent-child relationships between Objects, as well as to automate the searchers/filtering of data in openBIS.</p> Tip <p>We recommend the reader to launch a Jupyter Notebook in a Python environment with <code>pyBIS</code> installed, and run the commands shown throughout the next sections.</p>"},{"location":"part2-advanced_features/#creating-projects-and-other-entities","title":"Creating Projects and Other Entities","text":"<p>We can create new Projects by doing:</p> <pre><code>new_project = o.new_project(\n    code=\"&lt;NEW-PROJECT-CODE&gt;\",\n    space=my_space,\n)\nnew_project.save()\n</code></pre> <p>Sucess</p> <p>Do not forget to <code>save()</code> the newly created Projects or Entities after defining them.</p> <p>To create a new Collection, we need to know the <code>type</code> we want to define. Nevertheless, in the BAM Data Store we only use <code>COLLECTION</code> types for any Collection:</p> <pre><code>new_collection = o.new_collection(\n    code=\"&lt;NEW-COLLECTION-CODE&gt;\",\n    type=\"COLLECTION\",\n    project=new_project,\n)\nnew_collection.save()\n</code></pre>"},{"location":"part2-advanced_features/#creating-new-objects","title":"Creating New Objects","text":"<p>In order to create a new Object under a Collection or a Project, we need to know its <code>type</code> beforehand. This depends on the specific use-case where this is being applied, as this is the main building block of data modeling in openBIS (e.g., Conceptual Data Model in the BAM Wiki). You can see all the available Object types in the BAM Masterdata repository or in the openBIS Admin UI.</p> <p>In this example, we will assume that we are creating a new experimental step and assigning some dummy metadata to it. </p> <p>We first create the Object:</p> <pre><code>new_experimental_step = o.new_object(\n    code=\"&lt;NEW-OBJECT-CODE&gt;\",\n    type=\"EXPERIMENTAL_STEP\",\n    collection=new_collection,\n)\n</code></pre> <p>Note</p> <p>If we leave the <code>code</code> attribute empty, openBIS will automatically assign one based on the definition of <code>EXPERIMENTAL_STEP</code> followed by a 4-digit number (see <code>generated_code_prefix</code> for <code>EXPERIMENTAL_STEP</code>).</p> <p>Each Object in openBIS has some assigned properties to it. A Property is a metadata field used to describe such Object. It can be of different data types (e.g., string, integers, floats, etc.). One of the most relevant data types is CONTROLLEDVOCABULARY. These are specifically constrained values to a metadata field.</p> <p>We can list the available properties of an Object by doing:</p> <pre><code>new_experimental_step.props\n# in dictionary format:\n# new_experimental_step.props()\n</code></pre> <p>We can then define the properties by passing a dictionary:</p> <pre><code>new_experimental_step.props = {\n    \"$name\": : \"trying out pybis\",\n    \"finished_flag\": False,\n}\nnew_experimental_step.save()\n</code></pre> <p>Note that: - Each property has a defined data type. If the stored value does not match the expected data type (e.g., <code>finished_flag</code> is a BOOLEAN, hence if you pass a string, e.g., <code>\"False\"</code>, pyBIS will return an error). - Some properties are mandatory and some are optional. So if we save an object with some mandatory properties missing, we will get an error. - The properties can be passed directly when creating a object: <code>new_object(..., props={...})</code> - Alternatively, properties can be defined by using the key and assigning the value, e.g.: <code>new_experimental_ste[\"$name\"]: \"trying out pybis\"</code>.</p>"},{"location":"part2-advanced_features/#parent-child-relationships-between-objects","title":"Parent-child Relationships between Objects","text":"<p>Following the previous steps, imagine we create two additional experimental steps: <code>parent_experimental_step</code> and <code>child_experimental_step</code>.</p> <p>We can then create a parent-child relationship for our <code>new_experimental_step</code>:</p> <pre><code>new_experimental_step.parents = parent_experimental_step\nnew_experimental_step.children = child_experimental_step\nnew_experimental_step.save()\n</code></pre> <p>We can also add parents or children using the synthax:</p> <pre><code>parent_experimental_step.add_children(child_experimental_step)\nparent_experimental_step.save()\n</code></pre> <p>We can delete parent-child relationships:</p> <pre><code>parent_experimental_step.del_children(child_experimental_step)\nparent_experimental_step.save()\n</code></pre>"},{"location":"part2-advanced_features/#attaching-datasets","title":"Attaching datasets","text":"<p>Datasets can be created similarly to other entities, with the exception that we need to specify files attached to it. We only use <code>RAW_DATA</code> as the Dataset type:</p> <pre><code>new_dataset = o.new_dataset(\n    type=\"RAW_DATA\",\n    object=new_experimental_step,\n    files=[\"path-to-some-file\"]\n)\nnew_dataset.save()\n</code></pre> <p>We can also delete them:</p> <pre><code>new_dataset.delete(reason=\"We finished with the example\")\n</code></pre>"},{"location":"part2-advanced_features/#search-and-filters","title":"Search and Filters","text":"<p>You've already learned in Part 1 to discover what is available in an openBIS instance. However, there are more advanced filters/searches that can be done, including filtering Objects whose metadata is a specific value or under a certain threshold value.</p> <p>We will consider filtering Objects in this example.</p> <p>Typically, <code>get_objects()</code> and the similar methods return all the objects in an instance. For efficiency, it is better to create batches and loop over them to map the objects with the desired properties. We can then use the <code>count</code> and <code>start_with</code> parameters to code this:</p> <pre><code>start_with = 3 \n\nexperimental_steps = o.get_objects(type=\"EXPERIMENTAL_STEP\", count=6, start_with=start_with)\n</code></pre> <p><code>start_with</code>  specifies which element in the list of <code>get_objects()</code> to start with, while <code>count</code> returns a specific number of elements from the search. We use <code>type</code> to define the type of objects we want to return.</p> <pre><code>for step in experimental_steps:\n    print(f\"Experimental step: {step.code}\")\n</code></pre> <p>We can also get objects whose properties match certain values:</p> <pre><code>o.get_objects(where={\"$name\": \"* &lt;name-we-want-to-find&gt;\"}, props=[\"$name\"])\n</code></pre> <p>Here, the <code>props</code> attribute ensures that <code>$name</code> are returned in the result of the search.</p> <p>We can also use mathematical operators (<code>&gt;</code>, <code>&lt;</code>, <code>=</code>, <code>&gt;=</code>, <code>&lt;=</code>):</p> <pre><code>o.get_objects(registrationdate=\"&gt;2023-07-21\")\n</code></pre> <p>And more complex searches like:</p> <pre><code>o.get_objects(\n    space=\"MY_*\",  # return from spaces starting with MY_\n    type=\"*_STEP*\",  # any objects that contain _STEP in the type\n    withParents=\"*\",  # containing any parents\n    withChildren=[\n        \"/MY_SPACE/MY_PROJECT/MY_COLLECTION/SAMPLE*\",\n    ]  # containing children with code starting with SAMPLE\n)\n</code></pre>"},{"location":"part3-bam_parsers/","title":"Part 3 - BAM Parsers","text":"<p>Up until now, you've learned how to work with pyBIS to explore, create, and search metainformation in openBIS. Despite of their inmense help, individual pyBIS scripts suffer from a maintainability and findability issue: two different people can create different pyBIS scripts with the same functionality. That's why, in the context of creating new Objects and their relationships (i.e., automated data ingestion in openBIS), we decided to create an interface (defined in the BAM Masterdata GitHub repository), and offer you with the opportunity to create parser scripts in a standardize way.</p> <p>When making a decision if writing a Python script in pyBIS or with this infrastructure, you should ask yourself:</p> <ol> <li>Is this script used for reading metadata from files that are constantly produced in my laboratory?</li> <li>Is this script going to be used by others?</li> <li>Did I create logic that might not be specific to my script?</li> </ol> <p>If the answer to all this questions is \"yes\", then you should create a parser following the BAM Parser Infrastructure and documentation. We recommend following:</p> <ul> <li>A tutorial on how to parse data using BAM Masterdata</li> <li>How-to: Create a New Parser</li> </ul> <p>If you want to know more, you can read our Explanation: Parsing and ETL Structure in the Parser App.</p> <p>!!! question Why using this instead of pyBIS directly?     Besides the multiplicity issue, the BAM Parser Infrastructure allows you to quickly focus on parsing metadata of Objects, and not on connecting to openBIS, creating custom logic, etc. In a future, we are planning to deploy our own Parser App which will load these parsers into it to produce an easy-to-follow interface for other users. If your script does not follow the BAM Parser Infrastructure, then it won't be integrated in such app.</p>"}]}